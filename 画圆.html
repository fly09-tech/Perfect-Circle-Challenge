<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç§‘æŠ€ç”»åœ†æŒ‘æˆ˜ - å›ºå®šæ­£åœ†ç‰ˆ</title>
    <style>
        /* å…¨å±€å¸ƒå±€è°ƒæ•´ï¼šå·¦ä¾§æ’åè¡¨ + å³ä¾§æ¸¸æˆåŒº */
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            background: linear-gradient(to bottom, #000000, #0f0520);
            color: #00ffff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: relative; /* æ–°å¢ï¼šä¸ºæ°´å°å®¹å™¨æä¾›å®šä½å‚è€ƒ */
        }

        /* æ°´å°æ ·å¼ - æ ¸å¿ƒä¼˜åŒ–ï¼šå­—ä½“ç¼©å°+æ¨ªæ’ä¸æ¢è¡Œ */
        .watermark {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* å…³é”®ï¼šæ°´å°ä¸é®æŒ¡é¼ æ ‡/è§¦å±äº¤äº’ */
            z-index: 50; /* å±‚çº§ä»‹äºæ¸¸æˆåŒºå’Œå¼¹çª—ä¹‹é—´ï¼Œä¸å½±å“æ ¸å¿ƒäº¤äº’ */
            opacity: 0.12; /* ä½ä¸é€æ˜åº¦ï¼Œä¸å¹²æ‰°ä¸»å†…å®¹ */
        }

        .watermark-content {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotate(30deg); /* å€¾æ–œ30Â° */
            display: flex;
            flex-wrap: wrap;
            align-content: space-around;
            justify-content: space-around;
            font-size: 16px; /* å­—ä½“è°ƒå°ï¼ˆåŸ28pxâ†’16pxï¼‰ */
            font-weight: bold;
            color: #00ffff; /* ä¸ä¸»ç•Œé¢é’è‰²ä¸€è‡´ï¼Œè§†è§‰èåˆ */
            letter-spacing: 1px; /* å¾®è°ƒå­—é—´è·ï¼Œé¿å…æ‹¥æŒ¤ */
            white-space: nowrap; /* æ ¸å¿ƒï¼šå¼ºåˆ¶æ–‡æœ¬ä¸æ¢è¡Œ */
        }

        .watermark-text {
            width: 180px; /* é€‚é…å°å­—ä½“çš„å®½åº¦ */
            height: 100px; /* é€‚é…å°å­—ä½“çš„é«˜åº¦ */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* é˜²æ­¢æç«¯æƒ…å†µæ–‡æœ¬æº¢å‡º */
        }

        /* å·¦ä¾§æ’åè¡¨æ ¼å®¹å™¨ */
        #ranking-container {
            width: 280px;
            height: 100vh;
            padding: 20px 10px;
            background: rgba(0, 0, 30, 0.8);
            border-right: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff inset;
            flex-shrink: 0;
            overflow-y: auto;
            position: relative; /* ç¡®ä¿æ°´å°ä¸ä¼šè¦†ç›–æ’åè¡¨èƒŒæ™¯ */
            z-index: 1;
        }

        #ranking-title {
            text-align: center;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            font-size: 20px;
            margin-bottom: 15px;
        }

        /* ç§‘æŠ€é£æ ¼æ’åè¡¨æ ¼ */
        #ranking-table {
            width: 100%;
            border-collapse: collapse;
            color: #00ffff;
            font-size: 16px;
        }

        #ranking-table th, #ranking-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid rgba(0, 255, 255, 0.5);
        }

        #ranking-table th {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            background: rgba(255, 0, 255, 0.1);
        }

        #ranking-table tr:nth-child(even) {
            background: rgba(0, 255, 255, 0.05);
        }

        #ranking-table tr:hover {
            background: rgba(255, 0, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        /* å³ä¾§æ¸¸æˆä¸»å®¹å™¨ */
        #game-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0 20px;
            position: relative; /* ç¡®ä¿æ°´å°ä¸ä¼šè¦†ç›–æ¸¸æˆåŒºèƒŒæ™¯ */
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 8px 0;
            flex-shrink: 0;
        }

        h1 {
            font-size: 24px;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            margin: 0;
        }

        #game-container {
            flex: 1;
            position: relative;
            width: 97vmin;
            height: 97vmin;
            max-width: 1200px;
            max-height: 1200px;
            align-self: center;
            background-color: rgba(0, 0, 30, 0.7);
            box-shadow: 0 0 30px #00ffff, inset 0 0 30px #ff00ff;
            border: 2px solid #00ffff;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #reference-canvas { z-index: 1; } /* å‚è€ƒæ­£åœ†å±‚ */
        #draw-canvas { z-index: 2; } /* ç”¨æˆ·ç»˜åˆ¶å±‚ */

        #controls {
            padding: 10px 0;
            text-align: center;
            flex-shrink: 0;
            background: rgba(0, 0, 30, 0.5);
        }

        .info-line {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 18px;
            margin-bottom: 8px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
        }

        #message {
            font-size: 17px;
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            min-height: 24px;
            margin: 8px 0;
        }

        .buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            padding: 8px 20px;
            font-size: 16px;
            background: transparent;
            color: #ff00ff;
            border: 1.5px solid #ff00ff;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 15px #ff00ff;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #ff00ff;
            background: rgba(255, 0, 255, 0.1);
        }

        /* æ»šåŠ¨æ¡ç¾åŒ–ï¼ˆé€‚é…ç§‘æŠ€é£æ ¼ï¼‰ */
        #ranking-container::-webkit-scrollbar {
            width: 6px;
        }

        #ranking-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 30, 0.5);
            border-radius: 3px;
        }

        #ranking-container::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.6);
            border-radius: 3px;
            box-shadow: 0 0 5px #00ffff;
        }

        /* æ–°çºªå½•å¼¹çª—æ ·å¼ */
        #record-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100; /* å¼¹çª—å±‚çº§é«˜äºæ°´å° */
            width: 380px;
            padding: 25px;
            background: rgba(0, 0, 40, 0.95);
            border: 2px solid #ff00ff;
            border-radius: 15px;
            box-shadow: 0 0 40px #ff00ff, inset 0 0 20px #00ffff;
            display: none;
        }

        #modal-title {
            text-align: center;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            font-size: 22px;
            margin: 0 0 20px 0;
        }

        #record-input {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            background: rgba(0, 0, 30, 0.8);
            border: 1px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            outline: none;
            box-shadow: 0 0 10px #00ffff inset;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        #record-input::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 99; /* é®ç½©å±‚å±‚çº§é«˜äºæ°´å° */
            display: none;
        }
    </style>
</head>
<body>
    <!-- æ°´å°å®¹å™¨ - æ ¸å¿ƒæ–°å¢ -->
    <div class="watermark">
        <div class="watermark-content">
            <!-- é‡å¤æ°´å°æ–‡æœ¬ï¼ŒæŒ‰æ¯”ä¾‹é“ºæ»¡ï¼ˆæ•°é‡é€‚é…å°å­—ä½“ï¼‰ -->
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
            <div class="watermark-text">æ°´å°</div>
        </div>
    </div>

    <!-- å·¦ä¾§æ’åè¡¨æ ¼å®¹å™¨ -->
    <div id="ranking-container">
        <h2 id="ranking-title">å†å²é«˜åˆ†æ’å</h2>
        <table id="ranking-table">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>ç©å®¶åç§°</th>
                    <th>åˆ†æ•°</th>
                    <th>åœ†åº¦</th>
                </tr>
            </thead>
            <tbody id="ranking-body">
                <!-- æ’åæ•°æ®åŠ¨æ€ç”Ÿæˆ -->
            </tbody>
        </table>
    </div>

    <!-- å³ä¾§æ¸¸æˆä¸»åŒºåŸŸ -->
    <div id="game-wrapper">
        <header>
            <h1>ç§‘æŠ€ç”»åœ†æŒ‘æˆ˜</h1>
        </header>
        <div id="game-container">
            <canvas id="reference-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
        <div id="controls">
            <div class="info-line">
                <span id="score">æ€»åˆ†æ•°: 0</span>
                <span id="roundness">åœ†åº¦: 0.00%</span>
                <span id="high-score">å†å²æœ€é«˜åˆ†: 0</span>
            </div>
            <div id="message">æŒ‰ä½å¼€å§‹ç»˜åˆ¶</div>
            <div class="buttons">
                <button id="clear-btn">æ¸…ç©ºç”»å¸ƒ</button>
                <button id="clear-ranking-btn">æ¸…ç©ºæ’å</button>
            </div>
        </div>
    </div>

    <!-- æ–°çºªå½•å¼¹çª— -->
    <div id="modal-overlay"></div>
    <div id="record-modal">
        <h3 id="modal-title">æ­å–œï¼æ–°çºªå½•åˆ›é€ è€…ï¼</h3>
        <input type="text" id="record-input" placeholder="è¯·è¾“å…¥ä½ çš„åå­—ï¼ˆå¯è¾“å…¥æ±‰å­—/æ•°å­—/å­—æ¯ï¼‰" maxlength="10">
        <div class="modal-buttons">
            <button id="cancel-btn">å–æ¶ˆ</button>
            <button id="confirm-btn">ç¡®å®š</button>
        </div>
    </div>

    <audio id="bg-music" loop autoplay volume="0.3">
        <source src="https://cdn.pixabay.com/download/audio/2022/08/15/audio_4e3d0a0a1b.mp3?filename=neon-gaming-144377.mp3" type="audio/mpeg">
    </audio>
    <script>
        const container = document.getElementById('game-container');
        const referenceCanvas = document.getElementById('reference-canvas');
        const drawCanvas = document.getElementById('draw-canvas');
        const referenceCtx = referenceCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const roundnessElement = document.getElementById('roundness');
        const highScoreElement = document.getElementById('high-score');
        const messageElement = document.getElementById('message');
        const clearBtn = document.getElementById('clear-btn');
        const clearRankingBtn = document.getElementById('clear-ranking-btn');
        const rankingBody = document.getElementById('ranking-body');
        const beepSound = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//ugC1BAQAAD8PLwYAAAAAAAACAAAAAAAABgAAAAAAAIAAAAAAAAAA");

        // å¼¹çª—å…ƒç´ 
        const recordModal = document.getElementById('record-modal');
        const modalOverlay = document.getElementById('modal-overlay');
        const recordInput = document.getElementById('record-input');
        const cancelBtn = document.getElementById('cancel-btn');
        const confirmBtn = document.getElementById('confirm-btn');

        // å›ºå®šæ ¸å¿ƒå‚æ•°
        let centerX, centerY;
        const referenceRadius = 300;
        let isDrawing = false;
        let currentPath = [];
        let canvasSize = 0;
        let currentScore = 0;
        let highScore = 0; // å†å²æœ€é«˜åˆ†
        let rankingList = []; // æ’ååˆ—è¡¨ï¼ˆå­˜å‚¨{name, score, roundness}ï¼‰
        let newRecordData = null; // ä¸´æ—¶å­˜å‚¨æ–°çºªå½•æ•°æ®

        // åˆå§‹åŒ–æ’åè¡¨æ ¼
        function initRanking() {
            highScore = 0;
            rankingList = [];
            highScoreElement.textContent = `å†å²æœ€é«˜åˆ†: ${highScore}`;
            updateRankingTable();
        }

        // æ›´æ–°æ’åè¡¨æ ¼
        function updateRankingTable() {
            // æ¸…ç©ºè¡¨æ ¼å†…å®¹
            rankingBody.innerHTML = '';
            
            // æŒ‰åˆ†æ•°é™åºæ’åºï¼Œå–å‰10æ¡
            const sortedRanking = [...rankingList]
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);

            // ç”Ÿæˆè¡¨æ ¼è¡Œ
            sortedRanking.forEach((item, index) => {
                const tr = document.createElement('tr');
                
                // æ’ååˆ—ï¼ˆå‰3åç‰¹æ®Šæ ‡è®°ï¼‰
                const rankTd = document.createElement('td');
                rankTd.textContent = index + 1;
                if (index === 0) rankTd.style.color = '#ffd700'; // ç¬¬ä¸€åé‡‘è‰²
                else if (index === 1) rankTd.style.color = '#c0c0c0'; // ç¬¬äºŒåé“¶è‰²
                else if (index === 2) rankTd.style.color = '#cd7f32'; // ç¬¬ä¸‰åé“œè‰²
                tr.appendChild(rankTd);

                // ç©å®¶åç§°åˆ—
                const nameTd = document.createElement('td');
                nameTd.textContent = item.name || 'åŒ¿åç©å®¶';
                tr.appendChild(nameTd);

                // åˆ†æ•°åˆ—
                const scoreTd = document.createElement('td');
                scoreTd.textContent = item.score;
                tr.appendChild(scoreTd);

                // åœ†åº¦åˆ—
                const roundnessTd = document.createElement('td');
                roundnessTd.textContent = `${item.roundness.toFixed(2)}%`;
                tr.appendChild(roundnessTd);

                rankingBody.appendChild(tr);
            });

            // æ— æ•°æ®æ—¶æ˜¾ç¤ºå ä½è¡Œ
            if (sortedRanking.length === 0) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 4;
                td.textContent = 'æš‚æ— è®°å½•';
                td.style.color = 'rgba(0, 255, 255, 0.5)';
                tr.appendChild(td);
                rankingBody.appendChild(tr);
            }
        }

        // æ‰“å¼€æ–°çºªå½•å¼¹çª—
        function openRecordModal(score, roundness) {
            newRecordData = { score, roundness };
            recordInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
            recordModal.style.display = 'block';
            modalOverlay.style.display = 'block';
            recordInput.focus(); // è‡ªåŠ¨èšç„¦è¾“å…¥æ¡†
        }

        // å…³é—­æ–°çºªå½•å¼¹çª—
        function closeRecordModal() {
            recordModal.style.display = 'none';
            modalOverlay.style.display = 'none';
            newRecordData = null;
        }

        // æ·»åŠ æ–°åˆ†æ•°åˆ°æ’å
        function addToRanking(score, roundness, name = 'åŒ¿åç©å®¶') {
            // åˆ¤æ–­æ˜¯å¦åˆ›å†å²æ–°é«˜
            const isNewRecord = score > highScore;
            
            if (isNewRecord) {
                highScore = score;
                // æ‰“å¼€å¼¹çª—è®©ç”¨æˆ·è¾“å…¥åç§°
                openRecordModal(score, roundness);
            } else {
                // æ™®é€šåˆ†æ•°ç›´æ¥æ·»åŠ 
                rankingList.push({ name, score, roundness });
                highScoreElement.textContent = `å†å²æœ€é«˜åˆ†: ${highScore}`;
                updateRankingTable();
            }
        }

        function resizeCanvas() {
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvasSize = size;
            referenceCanvas.width = size;
            referenceCanvas.height = size;
            drawCanvas.width = size;
            drawCanvas.height = size;
            centerX = canvasSize / 2;
            centerY = canvasSize / 2;
            drawReferenceCircle();
        }

        function drawReferenceCircle() {
            referenceCtx.clearRect(0, 0, canvasSize, canvasSize);
            referenceCtx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            referenceCtx.lineWidth = 3;
            referenceCtx.shadowBlur = 20;
            referenceCtx.shadowColor = '#00ffff';
            referenceCtx.beginPath();
            referenceCtx.arc(centerX, centerY, referenceRadius, 0, Math.PI * 2);
            referenceCtx.stroke();
            referenceCtx.shadowBlur = 0;
        }

        function getMousePos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = canvasSize / rect.width;
            const scaleY = canvasSize / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function getTouchPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const scaleX = canvasSize / rect.width;
            const scaleY = canvasSize / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        function startNewGame() {
            resizeCanvas();
            drawCtx.clearRect(0, 0, canvasSize, canvasSize);
            currentPath = [];
            messageElement.textContent = 'æŒ‰ä½å¼€å§‹ç»˜åˆ¶';
            scoreElement.textContent = 'æ€»åˆ†æ•°: 0';
            roundnessElement.textContent = 'åœ†åº¦: 0.00%';
            currentScore = 0;
        }

        // å®æ—¶è®¡ç®—åœ†åº¦çš„æ ¸å¿ƒå‡½æ•°
        function calculateRealTimeRoundness(path) {
            if (path.length < 5) return 0;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const userRadiusX = (maxX - minX) / 2;
            const userRadiusY = (maxY - minY) / 2;
            const roundnessRatio = Math.min(userRadiusX, userRadiusY) / (Math.max(userRadiusX, userRadiusY) || 1);
            return roundnessRatio * 100;
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºå°é—­å›¾å½¢ï¼ˆèµ·ç‚¹ç»ˆç‚¹è·ç¦»é˜ˆå€¼ä¸ºå‚è€ƒåœ†åŠå¾„çš„5%ï¼‰
        function isClosedShape(path) {
            if (path.length < 20) return false; // ç¬”è¿¹è¿‡çŸ­ç›´æ¥åˆ¤å®šæœªå°é—­
            const start = path[0];
            const end = path[path.length - 1];
            const distance = Math.hypot(end.x - start.x, end.y - start.y);
            return distance < referenceRadius * 0.05; // è·ç¦»å°äº15pxè§†ä¸ºå°é—­
        }

        // è®¡ç®—ç¬”è¿¹ç»˜åˆ¶æ–¹å‘ï¼ˆè¿”å›1=é¡ºæ—¶é’ˆï¼Œ-1=é€†æ—¶é’ˆï¼Œ0=æ— æ–¹å‘ï¼‰
        function getDrawDirection(path) {
            if (path.length < 10) return 0;
            let sum = 0;
            // è®¡ç®—ç›¸é‚»ä¸‰ç‚¹çš„å‰ç§¯å’Œï¼Œåˆ¤æ–­æ•´ä½“æ—‹è½¬æ–¹å‘
            for (let i = 1; i < path.length - 1; i++) {
                const p0 = path[i - 1];
                const p1 = path[i];
                const p2 = path[i + 1];
                // å‘é‡å‰ç§¯ï¼š(p1-p0) Ã— (p2-p1)
                const cross = (p1.x - p0.x) * (p2.y - p1.y) - (p1.y - p0.y) * (p2.x - p1.x);
                sum += cross;
            }
            return sum > 0 ? -1 : sum < 0 ? 1 : 0; // é€†æ—¶é’ˆä¸º-1ï¼Œé¡ºæ—¶é’ˆä¸º1
        }

        // æ£€æµ‹ç»˜åˆ¶è¿‡ç¨‹ä¸­æ˜¯å¦å‡ºç°æ–¹å‘åè½¬
        function hasDirectionReversal(path) {
            if (path.length < 30) return false; // ç¬”è¿¹è¿‡çŸ­ä¸æ£€æµ‹æ–¹å‘
            const segmentLength = Math.floor(path.length / 3); // åˆ†3æ®µæ£€æµ‹
            // ç¬¬ä¸€æ®µæ–¹å‘
            const dir1 = getDrawDirection(path.slice(0, segmentLength));
            // ç¬¬äºŒæ®µæ–¹å‘
            const dir2 = getDrawDirection(path.slice(segmentLength, segmentLength * 2));
            // ç¬¬ä¸‰æ®µæ–¹å‘
            const dir3 = getDrawDirection(path.slice(segmentLength * 2));
            
            // ä»»æ„ä¸¤æ®µæ–¹å‘ç›¸ååˆ™åˆ¤å®šä¸ºåè½¬
            return (dir1 !== 0 && dir2 !== 0 && dir1 !== dir2) || 
                   (dir2 !== 0 && dir3 !== 0 && dir2 !== dir3) ||
                   (dir1 !== 0 && dir3 !== 0 && dir1 !== dir3);
        }

        function isExtremeMessy(path) {
            if (path.length < 20) return true;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const width = maxX - minX;
            const height = maxY - minY;
            if (width < referenceRadius * 0.1 || height < referenceRadius * 0.1) return true;
            return false;
        }

        function calculateFinalScore() {
            // 1. åŸºç¡€åˆ¤å®šï¼šè¿‡çŸ­/ä¹±ç”»
            if (currentPath.length < 10) {
                messageElement.textContent = 'ç”»å¾—å¤ªçŸ­äº†~';
                beepSound.currentTime = 0;
                beepSound.play();
                return;
            }
            if (isExtremeMessy(currentPath)) {
                scoreElement.textContent = 'æ€»åˆ†æ•°: 0';
                roundnessElement.textContent = 'åœ†åº¦: 0.00%';
                messageElement.textContent = 'ä¹±ç”»æ‰“å±å±å“¦ï¼ğŸ˜œ';
                beepSound.currentTime = 0;
                beepSound.play();
                return;
            }

            // 2. æ–°å¢åˆ¤å®šï¼šæœªå°é—­/æ–¹å‘åè½¬
            if (!isClosedShape(currentPath) || hasDirectionReversal(currentPath)) {
                scoreElement.textContent = 'æ€»åˆ†æ•°: 0';
                roundnessElement.textContent = 'åœ†åº¦: 0.00%';
                messageElement.textContent = 'è¿™å¥½åƒä¸æ˜¯ä¸€ä¸ªåœ†å“¦ï¼';
                beepSound.currentTime = 0;
                beepSound.play();
                return;
            }

            // 3. æ­£å¸¸è¯„åˆ†é€»è¾‘
            const xs = currentPath.map(p => p.x);
            const ys = currentPath.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const userCenterX = (minX + maxX) / 2;
            const userCenterY = (minY + maxY) / 2;
            const userRadiusX = (maxX - minX) / 2;
            const userRadiusY = (maxY - minY) / 2;
            const userRadius = (userRadiusX + userRadiusY) / 2;
            const centerDiff = Math.hypot(userCenterX - centerX, userCenterY - centerY);
            const radiusDiff = Math.abs(userRadius - referenceRadius);
            const roundnessRatio = Math.min(userRadiusX, userRadiusY) / Math.max(userRadiusX, userRadiusY || 1);
            const roundnessScore = roundnessRatio * 100;
            const centerScore = Math.max(0, 100 - centerDiff * 0.5);
            const radiusScore = Math.max(0, 100 - radiusDiff * 0.3);
            const shapeScore = roundnessScore;
            currentScore = Math.round((centerScore * 0.3 + radiusScore * 0.4 + shapeScore * 0.3));
            
            // æ›´æ–°æ˜¾ç¤º
            roundnessElement.textContent = `åœ†åº¦: ${roundnessScore.toFixed(2)}%`;
            scoreElement.textContent = `æ€»åˆ†æ•°: ${currentScore}`;
            
            // æ·»åŠ åˆ°æ’ååˆ—è¡¨
            addToRanking(currentScore, roundnessScore);

            // åé¦ˆä¿¡æ¯
            const feedback = currentScore >= 90 ? 'å®Œç¾ï¼ğŸ”¥' :
                             currentScore >= 75 ? 'ä¼˜ç§€ï¼âš¡' :
                             currentScore >= 55 ? 'ä¸é”™ï¼ğŸ’»' :
                             currentScore >= 30 ? 'ç»§ç»­åŠªåŠ›ï¼ğŸ˜Š' :
                             'å†ç»ƒä¹ å°±èƒ½æ›´å¥½å•¦~';
            messageElement.textContent = `å¾—åˆ†: ${currentScore} åˆ†ï¼ ${feedback}`;
            beepSound.currentTime = 0;
            beepSound.play();
        }

        // ç»˜åˆ¶äº‹ä»¶ - å¼€å§‹ç»˜åˆ¶
        drawCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            currentPath = [getMousePos(e)];
            messageElement.textContent = 'ç»˜åˆ¶ä¸­...';
        });

        // ç»˜åˆ¶äº‹ä»¶ - ç§»åŠ¨ç”»ç¬”ï¼ˆå®æ—¶æ›´æ–°åœ†åº¦ï¼‰
        drawCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getMousePos(e);
            currentPath.push(pos);
            const prev = currentPath[currentPath.length - 2];
            const grad = drawCtx.createLinearGradient(prev.x, prev.y, pos.x, pos.y);
            grad.addColorStop(0, '#00ffff');
            grad.addColorStop(0.5, '#ff00ff');
            grad.addColorStop(1, '#00ffcc');
            drawCtx.strokeStyle = grad;
            drawCtx.lineWidth = 3;
            drawCtx.lineCap = 'round';
            drawCtx.shadowBlur = 10;
            drawCtx.shadowColor = '#00ffff';
            drawCtx.beginPath();
            drawCtx.moveTo(prev.x, prev.y);
            drawCtx.lineTo(pos.x, pos.y);
            drawCtx.stroke();
            drawCtx.shadowBlur = 0;

            // å®æ—¶è®¡ç®—å¹¶æ›´æ–°åœ†åº¦
            const realTimeRoundness = calculateRealTimeRoundness(currentPath);
            roundnessElement.textContent = `åœ†åº¦: ${realTimeRoundness.toFixed(2)}%`;
        });

        // ç»“æŸç»˜åˆ¶
        function endDrawing() {
            if (isDrawing) {
                isDrawing = false;
                calculateFinalScore();
            }
        }

        drawCanvas.addEventListener('mouseup', endDrawing);
        drawCanvas.addEventListener('mouseout', endDrawing);

        // è§¦å±æ”¯æŒ - å¼€å§‹ç»˜åˆ¶
        drawCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            currentPath = [getTouchPos(e)];
            messageElement.textContent = 'ç»˜åˆ¶ä¸­...';
        });

        // è§¦å±æ”¯æŒ - ç§»åŠ¨ç”»ç¬”ï¼ˆå®æ—¶æ›´æ–°åœ†åº¦ï¼‰
        drawCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const pos = getTouchPos(e);
            currentPath.push(pos);
            const prev = currentPath[currentPath.length - 2];
            const grad = drawCtx.createLinearGradient(prev.x, prev.y, pos.x, pos.y);
            grad.addColorStop(0, '#00ffff');
            grad.addColorStop(0.5, '#ff00ff');
            grad.addColorStop(1, '#00ffcc');
            drawCtx.strokeStyle = grad;
            drawCtx.lineWidth = 3;
            drawCtx.lineCap = 'round';
            drawCtx.shadowBlur = 10;
            drawCtx.shadowColor = '#00ffff';
            drawCtx.beginPath();
            drawCtx.moveTo(prev.x, prev.y);
            drawCtx.lineTo(pos.x, pos.y);
            drawCtx.stroke();
            drawCtx.shadowBlur = 0;

            // å®æ—¶è®¡ç®—å¹¶æ›´æ–°åœ†åº¦ï¼ˆè§¦å±ç«¯åŒæ­¥ï¼‰
            const realTimeRoundness = calculateRealTimeRoundness(currentPath);
            roundnessElement.textContent = `åœ†åº¦: ${realTimeRoundness.toFixed(2)}%`;
        });

        drawCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            endDrawing();
        });

        // æ¸…ç©ºç”»å¸ƒæŒ‰é’®äº‹ä»¶
        clearBtn.addEventListener('click', () => {
            drawCtx.clearRect(0, 0, canvasSize, canvasSize);
            currentPath = [];
            messageElement.textContent = 'ç”»å¸ƒå·²æ¸…ç©º';
            scoreElement.textContent = 'æ€»åˆ†æ•°: 0';
            roundnessElement.textContent = 'åœ†åº¦: 0.00%';
            currentScore = 0;
        });

        // æ¸…ç©ºæ’åæŒ‰é’®äº‹ä»¶
        clearRankingBtn.addEventListener('click', () => {
            initRanking();
            messageElement.textContent = 'æ’åå·²æ¸…ç©º';
        });

        // å¼¹çª—å–æ¶ˆæŒ‰é’®äº‹ä»¶ï¼ˆæ¸…ç©ºè¾“å…¥å†…å®¹ï¼‰
        cancelBtn.addEventListener('click', () => {
            recordInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
            closeRecordModal();
            // å–æ¶ˆåä»æ·»åŠ åŒ¿åè®°å½•
            if (newRecordData) {
                rankingList.push({
                    name: 'åŒ¿åç©å®¶',
                    score: newRecordData.score,
                    roundness: newRecordData.roundness
                });
                highScoreElement.textContent = `å†å²æœ€é«˜åˆ†: ${highScore} (æ–°çºªå½•ï¼)`;
                updateRankingTable();
            }
        });

        // å¼¹çª—ç¡®å®šæŒ‰é’®äº‹ä»¶ï¼ˆä¿å­˜è¾“å…¥å†…å®¹ï¼‰
        confirmBtn.addEventListener('click', () => {
            const userName = recordInput.value.trim() || 'åŒ¿åç©å®¶';
            if (newRecordData) {
                rankingList.push({
                    name: userName,
                    score: newRecordData.score,
                    roundness: newRecordData.roundness
                });
                highScoreElement.textContent = `å†å²æœ€é«˜åˆ†: ${highScore} (æ–°çºªå½•ï¼)`;
                updateRankingTable();
            }
            closeRecordModal();
        });

        // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
        modalOverlay.addEventListener('click', () => {
            closeRecordModal();
            // é®ç½©å±‚å…³é—­ä¹Ÿæ·»åŠ åŒ¿åè®°å½•
            if (newRecordData) {
                rankingList.push({
                    name: 'åŒ¿åç©å®¶',
                    score: newRecordData.score,
                    roundness: newRecordData.roundness
                });
                highScoreElement.textContent = `å†å²æœ€é«˜åˆ†: ${highScore} (æ–°çºªå½•ï¼)`;
                updateRankingTable();
            }
        });

        window.addEventListener('resize', startNewGame);
        
        // åˆå§‹åŒ–
        initRanking();
        startNewGame();
    </script>
</body>
</html>
